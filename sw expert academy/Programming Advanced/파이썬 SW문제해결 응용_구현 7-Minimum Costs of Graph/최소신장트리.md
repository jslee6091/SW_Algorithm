### 최소 신장 트리 문제

- 가중치 그래프에서 모든 정점들을 연결하는 간선들의 가중치 합이 최소가 되는 트리를 찾는 문제
- 신장 트리(Spanning Tree)
  - n개의 정점을 포함하는 무향 그래프에서 n개의 정점과 n-1개의 간선으로 구성된 트리
  - 최소 신장 트리를 찾는 알고리즘은 Prim과 Kruskal Algorithm이 존재한다.



### Prim Algorithm

- 한 정점에 연결된 간선들 중 하나씩 선택하면서 최소 신장 트리를 만들어가는 방식

- ```python
  def MST_PRIM(G,s): # G는 그래프, s는 시작 정점
      # key는 pi에 저장된 간선의 가중치
      # 가중치를 무한대로 초기화
      key = [INF]*N
      # pi는 정점이 트리에 연결될 때 사용된 간선 정보
      # 트리에서 연결될 부모 정점 초기화
      pi = [None]*N
      # 방문 여부 초기화
      visited = [False]*N
      # 시작 정점의 가중치를 0으로 설정
      key[s] = 0
      
      # 정점의 개수만큼 반복
      for _ in range(N):
          minIndex = -1
          min = INF
          # 방문 안한 정점중 최소 가중치 정점 찾기
          for i in range(N):
              if not visited[i] and key[i] < min:
                  min = key[i]
                  minIndex = i
          # 최소 가중치 정점 방문처리
          visited[minIndex] = True
          # 선택 정점의 인접한 정점
          for v, val in G[minIndex]:
              if not visited[v] and val < key[v]:
                  # 가중치 갱신
                  key[v] = val
                  # 트리에서 연결될 부모 정점
                  pi[v] = minIndex
  ```





### Kruskal Algorithm

- 최소 가중치 간선을 하나씩 선택해서 최소 신장 트리를 찾는 알고리즘

  - N개의 정점을 포함하는 그래프에서 n-1개의 간선을 선택
  - 간선을 선택하는 과정에 여러 개의 트리들이 존재
  - 초기에는 n개의 정점들이 각각 하나의 트리이므로 하나의 정점을 포함하는 n개의 상호 배타 집합이 된다.
  - 간선을 선택하면 간선의 두 정점이 속한 트리가 연결되고 하나의 집합으로 합쳐짐
  - 선택한 간선의 두 정점이 이미 연결된 트리에 속한 경우 사이클이 생기는데 이를 방지하기 위해 두 정점에 대해 같은 집합의 원소인지 여부를 검사해야한다.

- 동작 과정

  1. 최초, 모든 간선을 가중치에 따라 오름차순 정렬
  2. 가중치가 가장 낮은 간선부터 선택하면서 트리 증가시킴
     - 사이클이 존재하면 다음으로 가중치가 낮은 간선 선택
  3. n-1개의 간선이 선택될 때까지 두 번째 과정을 반복

- 코드

  - ```python
    def MST_KRUSKAL(G):
        mst = []
        
        for i in range(N):
            Make_Set(i)
        
        G.sort(key = lambda t: t[2]) # 가중치 기준으로 정렬
        
        mst_cost = 0 # MST 가중치
        
        while len(mst) < N-1:
            u, v, val = G.pop(0) # 최소 가중치 간선 가져오기
            if Find_Set(u) != Find_Set(v):
                Union(u, V)
                mst.append((u, v)) # 트리에 (u,v) 추가
                mst_cost += val
    ```

- 간선 선택 과정에서 생성되는 트리를 관리하기 위해 상호 배타 집합 사용

  - 트리에 속한 노드들은 자신을 루트로 하는 서브트리의 높이를 랭크(Rank)라는 이름으로 저장

- 선택한 간선으로 두 개의 트리가 한개로 합쳐질때 각 트리에 해당하는 상호 배타 집합을 Union연산으로 합침

  - 랭크 값이 작은 트리를 랭크 값이 큰 트리의 서브트리로 포함시킬 경우 트리에 포함된 노드들의 랭크 값 수정 불필요함

