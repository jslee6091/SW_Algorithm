### 전위 순회 알고리즘

> 루트 노드 -> 왼쪽 노드 -> 오른쪽 노드
>
> 현재 노드 -> 왼쪽 서브트리 -> 오른쪽 서브트리

```python
def preorder_traverse(T):
    if T:
        visit(T) # print(T.item)
        preorder_traverse(T.left)
        preorder_traverse(T.right)
```



### 중위 순회 알고리즘

> 왼쪽 노드 -> 루트 노드 -> 오른쪽 노드
>
> 왼쪽 서브트리 -> 현재 노드 -> 오른쪽 서브트리

```python
def inorder_traverse(T):
    if T:
        inorder_traverse(T.left)
        visit(T) # print(T.item)
        inorder_traverse(T.right)
```



### 후위 순회 알고리즘

>왼쪽 노드 -> 오른쪽 노드 -> 루트 노드
>
>왼쪽 서브트리 -> 오른쪽 서브트리 -> 현재 노드

```python
def postorder_traverse(T):
    if T:
        postorder_traverse(T.left)
        postorder_traverse(T.right)
        visit(T) # print(T.item)
```





### List 이용한 Binary Tree 표현



- 전체 트리의 각 노드마다 번호를 부여함
  - 번호 부여 방식은 루트 노드가 1 이고 그 이후부터 각 레벨마다 왼쪽 노드부터 순서대로 번호를 부여함
- 부모 노드 = 자식 노드 // 2
- 왼쪽 자식 노드 = 부모 노드 * 2
- 오른쪽 자식 노드 = 부모  노드 *2 + 1
- 단점 :  편향 이진 트리의 경우 사용하지 않는 리스트 원소에 대한 메모리 공간 낭비 발생
  - 편향 이진 트리 : 자식 노드가 왼쪽 또는 오른쪽으로만 구성된 트리
- 이러한 단점을 보완하기 위해 *연결리스트*를 이용한다.
- 연결리스트는 3개의 영역으로 구성되는데 가운데 영역은 데이터, 왼쪽은 왼쪽 자식 노드를 가리키는 값, 오른쪽 영역은 오른쪽 자식 노드를 가리키는 값이다.



### Binary Search Tree (이진탐색트리)

> 서로 다른 키를 갖는 원소로 구성되어 탐색을 효율적으로 하기 위한 자료구조

- 왼쪽 서브트리 key < 루트 노드 key < 오른쪽 서브트리 key

- 중위 순회하면 오름차순으로 정렬할 수 있음
- 시간복잡도
  - 탐색, 삽입, 삭제 : O(h), h= 트리의 깊이(height)
  - 평균 - 이진 트리가 균형적으로 생성되어 있는 경우 : O(logn)
  - 최악 - 한쪽으로 치우친 경우 : O(n)
  - 최악의 경우에는 순차탐색과 시간복잡도가 같음



### 검색 알고리즘의 비교

> 시간복잡도



1. 리스트 순차 탐색
   - O(N)
2. 정렬된 리스트 순차 탐색
   - O(N)
3. 정렬된 리스트 순차 탐색
   - O(logN)
4. 해쉬 검색
   - O(1)





### Heap

> 완전 이진 트리를 이용한 자료구조

- 완전 이진 트리의 노드 중 키값이 가장 크거나 작은 노드를 찾는 자료구조
- 최대힙(Max heap)
  - 가장 큰 노드를 찾는 것
  - 부모 노드 > 자식 노드
  - 루트 노드 : 키값이 가장 큼
- 최소힙(Min heap)
  - 가장 작은 노드를 찾는 것
  - 부모 노드 < 자식 노드
  - 루트 노드 : 키값이 가장 작음
- 삽입 연산
  - 힙의 마지막 위치에 새로운 공간을 만들고 새 원소를 삽입
  - 부모 노드와 비교해가며 자리 바꾼 후 완료
- 삭제 연산
  - 힙에서는 루트 노드의 원소만 삭제한다.
  - 종류에 따라 최대값 또는 최소값을 구할 수 있다.
  - 따라서 우선순위 큐를 힙으로 구현이 가능하다.
- 삭제 연산 과정
  1. 루트 노드의 원소 삭제
  2. 마지막 노드를 루트 노드로 이동
  3. 자식 노드와 값을 비교하여 자리 바꾼후 완료

