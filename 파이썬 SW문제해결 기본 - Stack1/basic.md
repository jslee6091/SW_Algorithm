### Stack

- 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료구조
- 선형 구조를 가짐(자료 간의 관계가 1대1의 관계)
- 비선형 구조는 1대 N의 관계를 가지는데 예를 들어 트리가 있다.
- 마지막에 삽입한 자료를 가장 먼저 꺼냄
- 파이썬에서 리스트를 이용하여 구현함
- 스택에서 마지막에 삽입된 원소의 위치를 top이라고 함



### 연산

1. 삽입
   - 자료를 저장소에 저장하는 것
   - push라고 함
2. 삭제
   - 자료를 저장소에서 꺼내는 것
   - 삽입한 자료의 역순으로 꺼냄
   - pop이라고 함
3. isEmpty
   - Stack이 공백인지 아닌지 확인
4. peek
   - Stack의 top에 있는 item(원소)을 반환



### push 알고리즘

```python
def push(item):
	s.append(item)
```



### pop 알고리즘

```python
def pop():
	if len(s) == 0:
		#underflow
		return
	else:
		return s.pop(-1)
```





### 괄호검사

- 조건
  - 왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 함
  - 왼쪽 괄호가 먼저 나와야 함
  - 괄호 사이에는 포함 관계만 존재함
- 알고리즘 개요
  - 문자열에 있는 괄호를 차례대로 조사
  - 왼쪽 괄호를 만나면 스택에 삽입, 오른쪽 괄호를 만나면 삭제 후 짝이 맞는지 확인
  - 스택이 비어있거나 괄호의 짝이 맞지 않거나(대괄호와 소괄호 등등) 문자열 끝까지 조사한 후에도 스택에 괄호가 남아있으면 실패



### 함수 호출 관리

> 프로그램에서 함수 호출과 복귀에 따른 수행 순서 관리



- 함수 호출 발생 시 지역변수, 매개변수, 복귀할 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입
- 함수 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제하면서 프레임에 저장되어있던 복귀주소를 확인하고 복귀
- 함수 호출과 복귀를 반복하면서 전체 프로그램이 실행된 후 시스템 스택은 공백이 됨



### 재귀 호출

- 자기 자신을 호출하여 순환 하는 것

- 작업의 특성에 따라 일반적인 호출 방식보다 프로그램의 크기를 줄이고 간단하게 작성할 수 있음

- 디버깅이 어렵고 잘못 작성 시 수행 시간이 커짐

- 대표적인 예로 Factorial, 피보나치 수열이 있음

- ```python
  # 피보나치 수열 알고리즘
  # fibo()를 너무 많이 호출하는 문제가 있음 이를 해결하는 것이 Memoization
  def fibo(n):
      if n<2:
          return n
      else:
          return fibo(n-1) + fibo(n-2)
  ```



### Memoization

- 컴퓨터 프로그램을 실행할 때 이전에 계산한 값을 메모리에 저장해서 매번 다시 계산하지 않도록 하여 전체적인 실행속도를 향상시키는 기술

- DP(동적계획법)의 핵심 기술

- ```python
  # Memoization을 적용한 피보나치 수열
  def fibo1(n):
      global memo
      if n >= 2 and len(memo) <= n:
          memo.append(fibo1(n-1)+fibo1(n-2))
      return memo[n]
  memo= [0,1]
  ```



### DP(동적 계획법)

> Dynamic Programming 약자
>
> 그리디 알고리즘과 같이  최적화 문제를 해결하는 알고리즘

- 입력 크기가 작은 부분의 문제들을 먼저 해결한 후에 그 해들을 이용하여 더 큰 크기의 부분 문제들을 해결

- 최종적으로 원래 주어진 문제를 해결

- 피보나치 수열에 DP 적용

  - 문제를 부분 문제로 분할

  - ```
    fibonacci(n)은 fibonacci(n-1), fibonacci(n-2), ... , fibonacci(1), fibonacci(0)의 부분집합으로 나뉨
    ```

  - 부분문제로 나누는 일을 끝냈으면 가장 작은 문제부터 해를 구함

  - 결과를 테이블에 저장하고 이를 이용하여 상위 문제의 해를 구함

  - ```python
    def fibo2(n):
        f = [0,1]
        
        for i in range(2,n+1):
            f.append(f[i-1]+f[i-2])
        
        return f[n]
    ```

- DP 구현방식 

  - recursive 방식 : fibo1()
    - 재귀적 구조는 내부 시스템 호출 스택을 사용하는 overhead가 발생할 수 있음
  - iterative 방식 : fibo2()
    - Memoization을 재귀적 구조에 사용하는 것보다 반복적 구조로 DP를 구현한 것이 성능 면에서 효율적임



### 깊이 우선 탐색(DFS)

> 스택을 이용하여 비선형 구조인 그래프로 표현된 모든 자료를 검색함

- 시작 정점의 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색

- 더 이상 갈 곳이 없게 되면 가장 마지막에 만났던 갈림길 간선이 있는 정점으로 되돌아옴

- 다른 방향의 정점으로 탐색을 계속 반복하여 결국 모든 정점을 순회

- 가장 마지막에 만났던 갈림길로 되돌아가야 하므로 이때 스택을 이용

- ```python
  visited[], stack[] 초기화
  DFS(v)
  	v방문;
      visited[v]<- true;
      do{
          if(v의 인접 정점 중 방문 안 한 w 찾기)
          	push(v);
          while(w){
              w 방문;
              visited[w]<-true;
              push(w);
              v<=w;
              v의 인접 정점 중 방문 안 한 w 찾기
          }
          v<-pop(stack);
      }while(v)
  end DFS()
  ```

