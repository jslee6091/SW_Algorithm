### 부분집합의 합 문제

- 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제



### 부분 집합의 수

- 집합의 원소가 n개일때 공집합을 포함한 부분 집합의 수는 2^n개



### 부분 집합 구하기 1

```python
bit = [0,0,0,0]
for i in range(2):
	bit[0] = i						# 0번째 원소
	for j in range(2):
		bit[1] = j					# 1번째 원소
		for k in range(2):
			bit[2] = k				# 2번째 원소
            for l in range(2):
                bit[3] = l			# 3번째 원소
                print(bit)
	
```

- 위 코드 수행 결과 bit가 [0,0,0,0] 부터 [1,1,1,1]까지 모두 출력된다.
- 이때 bit의 원소가 1인 것을 부분집합으로 취급한다.
- ex) [0,0,0,1] = {4}, [0,1,1,1] = {2,3,4}, [1,0,1,0] = {1,3}



### 부분 집합 구하기 2

```python
arr= [3,6,7,1,5,4]
n = len(arr)

for i in range(1<<n): # 1<<n: 부분 집합의 개수
	for j in range(n): # 원소의 수만큼 비트를 비교
		if i&(1<<j): # i의 j번째 비트가 1이면 j번째 원소 출력
			print(arr[j], end=",")
```

- 1번 보다 더 간결하게 부분 집합을 생성하는 방법
- 원소의 포함 여부 판단이 가능함



### 순차 검색

- 일렬로 되어 있는 자료를 순서대로 검색하는 방법

- List 또는 Linked List 등 순차구조로 구현된 자료구조에서 유용함

- 구현이 쉽지만 검색 대상이 많은 경우 시간이 증가하여 비효율적이다.

- ```
  정렬되지 않은 자료의 검색
  ```

  - 첫번째 원소부터 순서대로 비교하여 찾는다.
  - 원하는 원소를 찾으면 그대로 종료
  - 마지막 원소까지 검색했음에도 찾지 못하면 실패
  - 시간 복잡도 : O(n)

- ```
  정렬된 자료의 검색
  ```

  - 오름차순 또는 내림차순으로 정렬된 상태에서 검색하는 경우
  - 자료를 순차적으로 검색하면서 값을 찾는다.
  - 원하는 값을 찾은 이후에는 더이상 찾고자 하는 자료가 없으므로 그대로 종료
  - 시간 복잡도 : O(n)



### 이진 검색

- 자료의 가운데 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속하는 방법

- 목적 키를 찾을 때까지 이진 검색을 반복하는데 이때 검색 범위를 반으로 줄이면서 빠르게 검색이 가능함

- 이진 검색을 위해서는 자료가 정렬되어야 함

- 시간 복잡도 : O(logN)

- ```
  이진 검색 과정
  1. 자료의 중앙에 있는 원소 선택
  2. 찾고자 하는 값과 비교 후 방향 설정
  3. 왼쪽인 경우 자료의 절반 왼쪽 부분에 대해서 중앙의 원소 선택 후 값 비교
  4. 원하는 값을 찾을때까지 반복
  ```

- 시작점과 종료점을 이용하여 검색을 반복 수행

- 자료의 삽입이나 삭제가 발생할 경우 List를 항상 정렬 상태로 유지시켜야 함



### 셀렉션 알고리즘

- 저장되어 있는 자료에서 k번째로 크거나 작은 원소를 찾는 방법
- 자료를 정렬 후 원하는 원소를 얻을 수 있다.



### k번째로 작은 원소 찾기

```python
def select(list, k):
    for i in range(0,k):
        minIndex = i
        for j in range(i+1, len(list)):
            if list[minIndex] > list[j]:
                minIndex = j
        list[i], list[minIndex] = list[minIndex], list[i]
    return list[k-1]
```

- 1번부터 k번째까지 작은 원소들을 찾아 List의 앞쪽으로 이동시키고 List의 k번째를 반환
- k가 비교적 작을때 유용하다.
- 시간복잡도 : O(kn)



### 선택 정렬

```python
def selectionSort(a):
    for i in range(0, len(a)-1):
        min = i
        for j in range(i+1, len(a)):
            if a[min] > a[j]:
                min = j
        a[i], a[min] = a[min], a[i]
```

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치 교환
- 셀렉션 알고리즘을 전체 자료에 적용한 것
- 정렬 과정
  - 주어진 List 중 최소값을 찾음
  - 그 값을 맨 앞의 값과 바꿈
  - 맨 앞의 원소를 제외한 나머지 원소들을 대상으로 위 과정을 반복
  - 시간 복잡도 : O(n^2)





